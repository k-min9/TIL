# 스프링 AOP

- 개념 : 핵심 기능과 부가 기능을 나누자
  - 횡단 관심사(cross-cutting concern) : 동일하게 사용되는 부가기능
- 관점(Aspect)을 바꾸면 부가 기능의 변경 지점이 하나가 되게 모듈화가 가능해짐
  - 이를 관점 지향 프로그래밍(AOP)라고 한다.
    - 횡단관심사를 깔끔히 처리하기 힘든 OOP의 부족한 부분을 보조하기 위해 개발
    - 효과 : 오류검사/처리 편의성, 동기화, 성능 최적화(캐싱), 모니터링 및 로깅
- 개요 : 스프링은 AOP의 AspectJ의 문법을 차용하고 기능의 일부를 제공.
  - 실무에서는 이 정도만 해도 충분하다
  - AspectJ의 문법을 쓰는거지 직접 사용하는 것이 아님.
- AOP 적용 방식
  - 컴파일 시점 : 위빙(Weaving). 적용대상에 직접 부가 로직을 추가
    - 특별한 컴파일러(AspectJ)가 필요하고 복잡
  - 클래스 로딩 시점 : 클래스를 JVM에 저장하는 시점에 위빙(로드 타임 위빙)
    - 클래스 로더 조작기를 지정하고 운영하기가 어려움
  - 런타임 시점(프록시) : 스프링 AOP. 자바가 실행 된 이후의 언어 내에서 부가 기능을 적용
    - 컨테이너, 프록시, DI, 빈 후처리기 같은 개념을 총 동원해야 함
    - 단 특별한 컴파일러나, 자바 실행시의 복잡한 옵션 및 클래스 로더 조작기 설정이 필요 없음
- 스프링 AOP 적용 위치
  - 위빙 계열 : 바이트 코드를 실제 조작해 모든 지점에 적용 가능
  - 런타임 시점 : 오버라이딩 개념으로 동작하는 프록시에서만 쓰기 때문에 메서드 실행(스프링 빈)에만 AOP를 적용 가능
- 용어 정리
  - 조인 포인트(Join point) : AOP를 적용할 수 있는 모든 지점(추상적 개념)
  - 포인트 컷 : 조인 포인트 중 어드바이스가 적용될 위치를 선별하는 기능.
    - AspectJ 표현식이나 스프링 AOP 메서드 실행 지점 선별을 사용해 지정
  - 타겟 : 어드바이스를 받는 객체, 포인트 컷으로 결정 된 대상
  - 어드바이스 : 부가 기능, Aspect에 의해 취해지는 조치
    - Around(주변), Before(전), After(후)와 같은 다양한 종류의 어드바이스가 있음
  - 애스팩트(Aspect) : @Aspect. 어드바이스 + 포인트 컷을 모듈화 한 것.
    - 여러 어드바이스와 포인트 컷이 함께 존재
  - 어드바이저 : 1 어드바이스 + 1 포인트 컷으로 구성. (스프링 AOP 전용 용어)
  - 위빙 : 포인트 컷으로 결정한 타겟의 조인 포인트에 어드바이스를 적용하는 것
  - AOP 프록시 : AOP 기능을 구현하기 위해 만든 프록시 객체
    - 스프링에서 AOP 프록시는 JDK 동적 프록시 또는 CGLIB 프록시

## Spring AOP

- 구현
  - @Aspect : 애스팩트라는 표식. 컴포넌트 스캔 기능 없음! 별도 빈 등록 필요
    - 참고 : 원래는 @EnableAspectJAutoProxy를 스프링 설정에 추가해야 쓸 수 있지만 스프링 부트가 자동 추가해 줌
    - 빈 등록 방법 :
      - @Bean 직접 등록
      - @Component로 컴포넌트 스캔 자동 등록
      - @Import로 설정파일 추가하듯이 class째 등록
  - @Around : 포인트 컷 지정. 해당 애노테이션 메서드를 어드바이스로 변경.
    - 첫 번째 파라미터는 무조건 ProceedingJoinPoint이고 joinPoint.proceed()를 호출해야 함
      - 그래야 다음 호출을 위한 chaining이 가능함
    - 거의 강력해서 얘만 써도 됨
      - 조인 포인트 실행(joinPoint.proceed()) 여부 선택
      - 전달 값 반환(joinPoint.proceed(args[]))
      - 반환 값, 예외 변환 가능
      - proceed() 를 여러번 실행할 수도 있음(재시도)
      - 기능 분리 : 분리가 되어 있어 chaining이 필요 없으므로, around와는 다르게 반드시 joinPoint.proceed()를 호출할 필요도 없고, 실수할 가능성도 적어짐. 그리고 의도가 명확해짐(좋은 설계 = 제약이 있는 코드)
        - @Before : 조인 포인트 실행 이전에 실행
        - @AfterReturning : 조인 포인트가 정상 완료후 실행
        - @AfterThrowing : 메서드가 예외를 던지는 경우 실행
        - @After : 조인 포인트가 정상 또는 예외에 관계없이 실행(finally)
  - @Pointcut : 포인트컷을 분리
  - @Order : @Aspect는 순서를 보장하지 않음. 순서 보장용.
    - @Aspect 단위로 별도의 클래스를 분리해서 나눠야 함
- 포인트 컷
  - 포인트 컷 표현식 : aspectJ가 제공하는 포인트컷 표현식.
    - execution 같은 포인트 컷 지시자로 시작
    - 포인트 컷 지시자
      - excution : 메소드 실행 조인 포인트를 매칭. 가장 많이 쓰임.
      - within : 특정 타입 내의 조인 포인트를 매칭한다.
      - args : 인자가 주어진 타입의 인스턴스인 조인 포인트. 단독 사용 불가.
        - Object arg1 = joinPoint.getArgs()[0]; 등의 코드를 쓰지 않고 깔끔한 코딩이 가능해짐
      - this vs target
        - this : 컨테이너 위 스프링 빈 객체(스프링 AOP 프록시)를 대상으로 하는 조인 포인트
        - target : Target 객체(스프링 AOP 프록시가 가르키는 실제 대상)를 대상으로 하는 조인 포인트
      - @target vs @within
        - @target : 인스턴스 기준으로 모든 메서드의 조인 포인트를 선정, 부모 타입의 메서드도 적용. 단독 사용 불가.
        - @within : 선택된 클래스 내부에 있는 메서드만 조인 포인트로 선정, 부모 타입의 메서드는 적용되지 않음
      - @annotation : 메서드가 주어진 애노테이션을 가지고 있는 조인 포인트를 매칭
        - annotation.value()로 실제 값을 꺼낼 수 있음
        - 받은 파라미터로 대체도 가능

        ``` java
          // 적용 전
          @Around("@annotation(hello.aop.exam.annotation.Trace)")
          public Object doRetry(ProceedingJoinPoint joinPoint)

          // 적용 후
          @Around("@annotation(retry)")
          public Object doRetry(ProceedingJoinPoint joinPoint, Retry retry)
        ```

      - @args : 전달된 실제 인수의 런타임 타입이 주어진 타입의 애노테이션을 갖는 조인 포인트. 단독 사용 불가.
      - bean : 스프링 전용 포인트컷 지시자, 빈의 이름으로 포인트컷을 지정한다
        - 단독사용 불가 지시자들 정리: args, @args, @target
          - 단독 사용시 전체 프록시 검사를 해버리는데 이때 final이 터지면 error 발생
    - 포인트 컷 매칭 조건
      ex) "execution(public String hello.aop.member.MemberServiceImpl.hello(String))"
      1. 접근제어자(public) : 생략 가능
      2. 반환타입(String)
      3. 선언 타입 : hello.aop.member.MemberServiceImpl
           - .. : 해당 위치의 패키지와 그 하위 패키지도 포함
      4. 메서드 이름 : hello
      5. 파라미터 : String
           - (..) 파라미터의 종류와 수를 신경쓰지 않겠다.
      6. 예외 : 생략
- 스프링 AOP 공식 지원 대표 예시 : @Transactional, @Async(동기->비동기 지원)
- 주의사항
  - 프록시와 내부 호출
    - 개요 : AOP 적용시 스프링은 대상(target) 객체 대신 프록시를 빈으로 등록. 객체 내부에서 호출이 발생하면 이 프록시를 거치지 않고 대상 객체를 직접 호출하는데 이때 문제 발생
    - 배경 : 스프링 AOP가 로드 타임 위빙, 프록시 방식의 AOP라서 발생하는 문제
    - 해설 : 자바언어는 메서드 앞에 별도의 참조가 없으면 자기 자신을 참조하는 this.메소드()로 호출을 하는데, 이러한 호출은 프록시를 거치지 않으니 어드바이스도 적용할 수 없음
    - 대안
      - 대안 1 : 자기 자신 주입 후 자신이름.메소드()로 호출
        - 주의 : 생성자 주입이 아닌 수정자(setter 사용) 주입할 것 (순환 참조 회피)
        스프링부트 2.6 이상에서는 순환 참조 원칙 금지로 바뀌므로 아래 설정 필요

          ``` yaml
          spring.main.allow-circular-references=true
          ```

      - 대안 2 : 지연 조회 / AplicationContext 내지 ObjectProvider 사용.
        - 너무 규모가 큰 AplicationContext 쓰지 말고 ObjectProvider 쓰자
      - 대안 3 : 구조 변경 / 내부 호출을 하지말고 클래스를 나누자.
        - 가장 깔끔한 편. 스프링 권장.
  - 프록시 기술의 한계
    - 타입 캐스팅 : 인터페이스 기반으로 프록시를 생성하는 JDK 동적 프록시는 구체 클래스로 타입 캐스팅이 불가능한 한계가 있다.
    - 의존 관계 주입 : 위 캐스팅 문제때문에, JDK 동적 프록시는 구체 클래스에 의존 관계를 주입할 수 없다. 제대로 된 설계면 인터페이스 기반 의존관계 주입이니 거의 일어나지 않기는 함! 다만 테스트라던가 머리 아파진다...
    - CGLIB의 단점 : 위의 두 문제가 해결 되지만, 이 기술도 단점이 있다.
      - 대상 클래스에 기본 생성자 필수
      - 구현 객체 생성자 두 번 호출 문제
        - target 객체 생성할때, 프록시 객체 생성할때 부모 클래스로서
      - final 키워드 클래스, 메서드 사용 불가.
        - CGLIB는 상속을 기본으로 하고 있으므로 final 쓸 수 없음.
        실무에서 AOP 적용대상에는 final 잘 안쓰므로 큰 문제는 아님.
    - 스프링의 해결책
      - 스프링 3.2부터 CGLIB를 스프링 내부에 함께 패키징
      - 스프링 4.0부터 CGLIB의 기본 생성자 필수 문제, 생성자 두 번 호출 문제 각각 해결
        - objenesis 라는 라이브러리 사용
      - 스프링부트 2.0에서 CGLIB를 기본으로 설정 (proxyTargetClass=True가 기본값)
