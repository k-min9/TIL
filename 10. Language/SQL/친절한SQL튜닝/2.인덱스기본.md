# 2. 인덱스 기본

- 개요 : 인덱스 구조와 탐색 원리
  - 강조하고 싶은것은 인덱스 탐색 과정 두 단계 : 수직적 탐색과 수평적 탐색

## 2.1 인덱스 구조 및 탐색

### 2.1.1 미리보는 인덱스 튜닝

- 개요 : DBMS는 수십년에 걸쳐 발전했지만, 전체 스캔과 인덱스 이용 이 두가지에서 크게 벗어나지 못하고 있음
  - 전체스캔은 튜닝요소가 적지만 인덱스는 튜닝요소가 많고 기법이 다양
  - 인덱스 튜닝 배경 예시 : 온라인 트랜잭션 처리(OLTP; Online Transaction Processing) 같은 소량 데이터 검색에 유용
- 인덱스 튜닝 두 가지 핵심요소
  - 1. 인덱스 스캔 효율화 튜닝
    - 어떤 컬럼을 인덱스로 활용해야 할까?
  - 2. 랜덤 액세스 최소화 튜닝 : 테이블 액세스 횟수 줄이기
    - 인덱스 스캔 효율화보다 성능에 미치는 영향이 크다.
- 결론 : SQL 튜닝은 랜덤 IO와의 전쟁
  - 앞으로 배울 수많은 기능들이 이 랜덤 IO 때문에 생겼음

### 2.1.2 인덱스 구조

- 인덱스 : 대용량 테이블에서 필요한 데이터만 빠르게 효율적으로 액세스하기 위해 사용하는 오브젝트
  - 전체 스캔에서 범위 스캔을 가능하게 해줌
  - 자료구조 : B*Tree
    - 루트>브랜치>리프로 구성되며 각각 하위 블록에 대한 주소값을 보유
    - LMC(Leftmost Child) : 자식 노드 중 가장 왼쪽 끝 블록. 최소치
    - 리프블록은 키 값으로 정렬되어 ROWID를 가짐
      - ROWID = 데이터 블록 주소(DBA) + 로우 번호
      - 데이터 블록 주소 = 데이터 파일 번호 + 블록 번호
      - 블록 번호 : 데이터 파일 내 상대적 순번 / 로우 번호 : 블록 내 순번
  - 탐색 과정 2단계
    - 수직적 탐색 : 인덱스 스캔 시작지점을 찾는 과정
    - 수평적 탐색 : 데이터를 찾는 과정

### 2.1.3 인덱스 수직적 탐색

- 조건을 만족하는 '첫번째' 레코드(인덱스 스캔지점)를 찾는 과정
  - 루트부터 브랜치를 거쳐 리프 블록까지 수직적 탐색
  - 여럿이 만족해도 최초 레코드만

### 2.1.4 인덱스 수평적 탐색

- 수직적 탐색으로 찾은 인덱스 리프 블록을 수평적으로 탐색
  - 리프블록끼리는 double linked list로 서로의 주소값을 가짐
  - 만족하는 데이터를 '전부' 찾는다. 이때, 테이블 액세스까지 고려해 ROWID도 같이 가져간다.

### 2.1.5 결합 인덱스 구조와 탐색

- 두 개 이상의 컬럼을 결합해 인덱스를 만들 수 있다.

    ``` sql
    create index 고객_N1 on 고객(성별, 고객명);
    ```

  - 이때의 인덱스는 A & B의 결합 키 같은 형태가 된다.
  - 결합 인덱스 컬럼의 선두 조건이 전부 '='라면,  
  어느 컬럼을 앞에 두던 블록 IO 갯수가 같아 성능도 같다.
