# 2. 인덱스 기본

- 개요 : 인덱스 구조와 탐색 원리
  - 강조하고 싶은것은 인덱스 탐색 과정 두 단계 : 수직적 탐색과 수평적 탐색

## 2.1 인덱스 구조 및 탐색

### 2.1.1 미리보는 인덱스 튜닝

- 개요 : DBMS는 수십년에 걸쳐 발전했지만, 전체 스캔과 인덱스 이용 이 두가지에서 크게 벗어나지 못하고 있음
  - 전체스캔은 튜닝요소가 적지만 인덱스는 튜닝요소가 많고 기법이 다양
  - 인덱스 튜닝 배경 예시 : 온라인 트랜잭션 처리(OLTP; Online Transaction Processing) 같은 소량 데이터 검색에 유용
- 인덱스 튜닝 두 가지 핵심요소
  - 1. 인덱스 스캔 효율화 튜닝
    - 어떤 컬럼을 인덱스로 활용해야 할까?
  - 2. 랜덤 액세스 최소화 튜닝 : 테이블 액세스 횟수 줄이기
    - 인덱스 스캔 효율화보다 성능에 미치는 영향이 크다.
- 결론 : SQL 튜닝은 랜덤 IO와의 전쟁
  - 앞으로 배울 수많은 기능들이 이 랜덤 IO 때문에 생겼음

### 2.1.2 인덱스 구조

- 인덱스 : 대용량 테이블에서 필요한 데이터만 빠르게 효율적으로 액세스하기 위해 사용하는 오브젝트
  - 전체 스캔에서 범위 스캔을 가능하게 해줌
  - 자료구조 : B*Tree
    - 루트>브랜치>리프로 구성되며 각각 하위 블록에 대한 주소값을 보유
    - LMC(Leftmost Child) : 자식 노드 중 가장 왼쪽 끝 블록. 최소치
    - 리프블록은 키 값으로 정렬되어 ROWID를 가짐
      - ROWID = 데이터 블록 주소(DBA) + 로우 번호
      - 데이터 블록 주소 = 데이터 파일 번호 + 블록 번호
      - 블록 번호 : 데이터 파일 내 상대적 순번 / 로우 번호 : 블록 내 순번
  - 탐색 과정 2단계
    - 수직적 탐색 : 인덱스 스캔 시작지점을 찾는 과정
    - 수평적 탐색 : 데이터를 찾는 과정

### 2.1.3 인덱스 수직적 탐색

- 조건을 만족하는 '첫번째' 레코드(인덱스 스캔지점)를 찾는 과정
  - 루트부터 브랜치를 거쳐 리프 블록까지 수직적 탐색
  - 여럿이 만족해도 최초 레코드만

### 2.1.4 인덱스 수평적 탐색

- 수직적 탐색으로 찾은 인덱스 리프 블록을 수평적으로 탐색
  - 리프블록끼리는 double linked list로 서로의 주소값을 가짐
  - 만족하는 데이터를 '전부' 찾는다. 이때, 테이블 액세스까지 고려해 ROWID도 같이 가져간다.

### 2.1.5 결합 인덱스 구조와 탐색

- 두 개 이상의 컬럼을 결합해 인덱스를 만들 수 있다.

    ``` sql
    create index 고객_N1 on 고객(성별, 고객명);
    ```

  - 이때의 인덱스는 A & B의 결합 키 같은 형태가 된다.
  - 결합 인덱스 컬럼의 선두 조건이 전부 '='라면,  
  어느 컬럼을 앞에 두던 블록 IO 갯수가 같아 성능도 같다.

## 2.2 인덱스 기본 사용법

- 개요 : Range Scan 하는 방법을 익히자

### 2.2.1 인덱스를 사용한다는 것

- 인덱스를 가공하거나 중간값을 사용하면 스캔 시작점을 찾을 수 없다.

### 2.2.2 인덱스를 Range Scan 할 수 없는 이유

- 스캔 불가 인덱스 가공 예시 : 시작지점과 끝지점을 모름
  - substr로 인덱스 컬럼의 중간 지점을 사용
  - nvl로 치환된 값
  - like의 '%%'를 써서 중간 값을 사용
  - where의 or 절에 다른 컬럼이 걸려 있음
    - 단, or 조건식을 sql 옵티마이저가 union all 형태로 늘려서 변환하여(Or expansion)  
    Index Range Scan을 적용할 수 있음  
    use_concat 힌트로 유도할 수 있음  
  - in도 결국 or 표현 방식 중 하나이기 때문에 위와 같은 변환이 필요
    - sql optimizer은 in을 list 개수 만큼 index range scan을 반복하는 IN-List iterator 방식 사용

### 2.2.3 더 중요한 인덱스 사용 조건

- 인덱스 사용 조건은 인덱스 선두 컬럼이 가공되지 않은 상태로 조건절에 있을 것
- 인덱스가 Range Scan한다고 무조건 성능이 좋은 것은 아님.
  - 스캔하는 블록수를 항상 확인하자.

### 2.2.4 인덱스를 이용한 소트 연산 생략

- 인덱스는 정렬되어있다는 대전제를 잊지 말자.
  - 즉 소트 연산 생략효과를 부수적으로 얻을 수 있다.
  - SQL 옵티마이저는 이 부분을 이미 활용하고 있고, 내림차순에도 대응한다.

### 2.2.5 ORDER BY 절에서 컬럼 가공

- 일반적으로 인덱스를 사용하지 못하는 인덱스 컬럼 가공은 조건절을 생각하지만 order by인 경우도 있다.
  - 인덱스는 가공되지 않은 상태로 저장하니, 가공값 기준으로 정렬을 요청하면 안된다.
    - 다른 곳에서 함수로 가공하고 선언된 alias로 정렬하는 경우
    - A+B+C로 이루어진 인덱스에서 B나 C로 정렬할 경우

### 2.2.6 SELECT-LIST 에서 컬럼 가공

- MIN, MAX를 사용시 인덱스 컬럼은 수직적 탐색으로 빠르게 찾아준다.
  - 요약 : MAX(TO_NUMBER(컬럼)) 같이 가공 컬럼에 MAX를 쓰지 말고  
  TO_NUMBER(MAX(변경순번)) 처럼 MAX를 하고 가공해라.

### 2.2.7 자동 형변환

- SQL에서는 기본적으로 데이터 타입이 다를 경우, 자동으로 형변환을 해줌
  - LIKE :null이들어올만한컬럼 || '%' 같은 SQL을 사용시 문자열로 변환하며 인덱스 액세스 조건으로 사용을 못함
  - 형변환함수 생략해도 SQL 옵티마이저가 자동생성하기 때문에 의미 없음.
- 결론 : 자동형변환은 편리하지만 의존하지 말고 반대편 컬림 또는 값을 정확히 형변환하자.
