# 1. SQL 처리과정과 I/O

## 1.1 SQL 파싱과 최적화

### 1.1.1 구조적, 집합적, 선언적 질의 언어

- SQL(Structured Query Language) : 구조적 질의 언어
  - 구조적(Structued)이고 집합적(Set-based)이고 선언적(Declarative)인 질의언어
- SQL 옵티마이저 : 결과집합을 만드는 절차적 과정, 프로시저를 만들어내는 DBMS 내부 엔진

### 1.1.2 SQL 최적화

- 과정 : SQL 파싱 > SQL 최적화(옵티마이저) > 로우소스 생성(포맷팅)
  - 결과물 : 프로시저
  - 파싱 : 파싱트리생성 > Syntax(문법오류) 체크 > Sementic(권한,테이블,컬럼유무) 체크

### 1.1.3 SQL 옵티마이저

- 개요 : 작업을 가장 효율적으로 수행할 수 있는 최적의 데이터 경로를 선택하는 DBMS 핵심 엔진

### 1.1.4 실행 계획과 비용

- 실행 계획(Execution Plan) : SQL 옵티마이저가 생성한 처리절차를 사용자가 확인할 수 있게 트리구조로 표현한 것
  - Cost : 쿼리를 수행하는데 발생할 것으로 예상하는 IO횟수 또는 예상 소요시간. 옵티마이저가 선택하는 근거.
  
### 1.1.5 옵티마이저 힌트

- 개요 : 개발자가 직접 더 효율적인 액세스 경로를 찾아내고 바꿀 수 있게 함
- 사용법 : 주석기호에 + 붙이기
  - ex> /*+ INDEX(A 고객PK)*/
  - 목록 : 최적화, 액세스 방식, 조인순서, 조인방식, 서브쿼리팩토링, 쿼리 변환, 병렬 처리, 기타
  - 주의 : 힌트간 콤마 금지, 스키마 명시 금지, ALIAS 있을 경우 무조건 사용, 가능한 자세히

## 1.2 SQL 공유 및 재사용

### 1.2.1 소프트 파싱 vs 하드 파싱

- 라이브러리 캐시 : 생성한 내부 프로시저를 반복 재사용할 수 있도록 캐싱해두는 메모리 공간. SGA 구성요소.
  - SGA(System Global Area) : 서버 프로세스와 백그라운드 프로세스가 공통으로 액세스하는 데이터와 제어구조를 캐싱하는 메모리 공간
- 전달받은 SQL문을 파싱한 후,
  - 소프트 파싱 : 해당 SQL이 라이브러리에 있을 경우 바로 실행
  - 하드 파싱 : 라이브러리에 없어서 내부 프로시저 생성 단계를 거침
    - 경우의 수도 많고, 고려할 것도 많음 -> 라이브러리 캐시가 필요한 이유 : 재사용

### 1.2.2 바인드 변수의 중요성

- 이름없는 SQL
  - SQL은 전체 텍스트가 하나의 객체고 이름. 조금만 변경되어도 다른 객체
  - 거기에 일회성이나 무효화 SQL까지 저장해서는 SQL 찾는 속도가 느려지기에 저장을 일반적으로 제공하지 않음
  - 단, IBM DB2는 SQL을 저장해주고, 오라클에서는 이를 1:1로 대응하는 SQL ID를 제공하기는 함
- 공유 가능 SQL
  - 라이브러리 캐시에서 사용하는 키값은 SQL문 그 자체가 됨
  - 약간의 대소문자 차이도 다른 SQL문으로 인식하고 각각 하드 파싱이 일어나게 됨
  - 바인드 변수("?")를 통해 하드 파싱이 단 한번만 일어나게 해야 함
