# 1. SQL 처리과정과 I/O

## 1.1 SQL 파싱과 최적화

### 1.1.1 구조적, 집합적, 선언적 질의 언어

- SQL(Structured Query Language) : 구조적 질의 언어
  - 구조적(Structued)이고 집합적(Set-based)이고 선언적(Declarative)인 질의언어
- SQL 옵티마이저 : 결과집합을 만드는 절차적 과정, 프로시저를 만들어내는 DBMS 내부 엔진

### 1.1.2 SQL 최적화

- 과정 : SQL 파싱 > SQL 최적화(옵티마이저) > 로우소스 생성(포맷팅)
  - 결과물 : 프로시저
  - 파싱 : 파싱트리생성 > Syntax(문법오류) 체크 > Sementic(권한,테이블,컬럼유무) 체크

### 1.1.3 SQL 옵티마이저

- 개요 : 작업을 가장 효율적으로 수행할 수 있는 최적의 데이터 경로를 선택하는 DBMS 핵심 엔진

### 1.1.4 실행 계획과 비용

- 실행 계획(Execution Plan) : SQL 옵티마이저가 생성한 처리절차를 사용자가 확인할 수 있게 트리구조로 표현한 것
  - Cost : 쿼리를 수행하는데 발생할 것으로 예상하는 IO횟수 또는 예상 소요시간. 옵티마이저가 선택하는 근거.
  
### 1.1.5 옵티마이저 힌트

- 개요 : 개발자가 직접 더 효율적인 액세스 경로를 찾아내고 바꿀 수 있게 함
- 사용법 : 주석기호에 + 붙이기
  - ex> /*+ INDEX(A 고객PK)*/
  - 목록 : 최적화, 액세스 방식, 조인순서, 조인방식, 서브쿼리팩토링, 쿼리 변환, 병렬 처리, 기타
  - 주의 : 힌트간 콤마 금지, 스키마 명시 금지, ALIAS 있을 경우 무조건 사용, 가능한 자세히

## 1.2 SQL 공유 및 재사용

### 1.2.1 소프트 파싱 vs 하드 파싱

- 라이브러리 캐시 : 생성한 내부 프로시저를 반복 재사용할 수 있도록 캐싱해두는 메모리 공간. SGA 구성요소.
  - SGA(System Global Area) : 서버 프로세스와 백그라운드 프로세스가 공통으로 액세스하는 데이터와 제어구조를 캐싱하는 메모리 공간
- 전달받은 SQL문을 파싱한 후,
  - 소프트 파싱 : 해당 SQL이 라이브러리에 있을 경우 바로 실행
  - 하드 파싱 : 라이브러리에 없어서 내부 프로시저 생성 단계를 거침
    - 경우의 수도 많고, 고려할 것도 많음 -> 라이브러리 캐시가 필요한 이유 : 재사용

### 1.2.2 바인드 변수의 중요성

- 이름없는 SQL
  - SQL은 전체 텍스트가 하나의 객체고 이름. 조금만 변경되어도 다른 객체
  - 거기에 일회성이나 무효화 SQL까지 저장해서는 SQL 찾는 속도가 느려지기에 저장을 일반적으로 제공하지 않음
  - 단, IBM DB2는 SQL을 저장해주고, 오라클에서는 이를 1:1로 대응하는 SQL ID를 제공하기는 함
- 공유 가능 SQL
  - 라이브러리 캐시에서 사용하는 키값은 SQL문 그 자체가 됨
  - 약간의 대소문자 차이도 다른 SQL문으로 인식하고 각각 하드 파싱이 일어나게 됨
  - 바인드 변수("?")를 통해 하드 파싱이 단 한번만 일어나게 해야 함

## 1.3 데이터 저장 구조 및 IO 매커니즘

### 1.3.1 SQL이 느린 이유

- 개요 : SQL이 느린 이유는 십중팔구 IO때문
  - 디스크 IO 동안 프로세스는 대기

### 1.3.2 데이터베이스 저장 구조

- 구조 : 테이블스페이스 > 세그먼트 > 익스텐트 > 블록(페이지)
  - 테이블스페이스 : 세그먼트를 담는 콘테이너
  - 세그먼트 : 데이터 저장공간이 필요한 오브젝트 : 테이블, 인덱스, 파티션, LOB 등
    - 익스텐트끼리는 연속하지 않음
    - 데이터파일과 다대다 관계
  - 익스텐트 : 공간을 확장하는 단위. 연속된 블록의 집합
  - 블록 : 데이터를 읽고 쓰는 단위
- DBA(Data Block Address) : 데이터 블록의 고유 주소값
  - 인덱스 ROWID : 인덱스를 통해 테이블 레코드를 읽을때 활용. DBA+로우 번호(블록 내 순번)로 구성

### 1.3.3 블록단위 IO

- IO의 최소단위가 블록이기 때문에 1byte만 읽을 일이어도 8kb(오라클 블록 기본 크기)를 읽는다.

### 1.3.4 시퀀셜 액세스 vs 랜덤 액세스

- 개요 : 테이블 또는 인덱스 블록을 액세스 하는 방식
  - 시퀀셜 : 논리적 또는 물리적으로 연결된 순서에 따라 차례대로. Full Scan
  - 랜덤 : 논리적, 물리적 순서를 따르지 않고, 레코드 하나를 읽기 위해 한 블록씩 접근하는 방식

### 1.3.5 논리적 IO vs 물리적 IO

- DB 버퍼 캐시 : SGA의 구성요소 중 데이터 캐시. 데이터 블록보다 먼저 접근하여 탐색
  - 공유 메모리 영역이라 다른 프로세스 접근도 캐싱됨
- 논리적 IO : SQL 처리 과정 중 발생한 총 블록 IO. (=메모리 IO와 같은 수치, 전기적 신호이니 빠름)
  - 몇 번을 실행해도 같은 블록수를 읽어옴. 일정할 수 밖에 없음.
- 물리적 IO : 디스크에서 발생한 총 블록 IO. (=버퍼캐시에 없는 블록 접근, 물리적인 만큼 느림)
  - 시스템 상황에 따라지는(=제어할 수 없는) 변수
- 버퍼캐시 히트율 : BCHR. 버퍼캐시 효율 측정 지표. 물리IO를 수반하지 않고 메모리에서 찾은 비율
  - BCHR = (캐시hit/총읽는블록수)*100 = ((논리IO-물리IO)/논리IO)*100
  - 의외로 무조건 높다고 좋은게 아니라고 한다.
- 결론 : SQL 성능향상을 위해서는 논리IO를 줄여야함

### 1.3.6 Single Block IO vs Multiblock IO

- 캐시에서 찾지 못한 데이터 블록은 IO Call을 통해 디스크에서 DB 버퍼캐시로 적재하고 읽음
  - Single Block : 한 번에 한 블록씩 적재
    - 인덱스를 이용한 조회에 주로 사용
  - Multiblock : 한 번에 여러 블록 적재. 배치 IO
    - 전체 스캔시 주로 사용, 단위를 크게하면 성능이 좋아짐
    - OS에서는 주로 1MB단위(오라클이 8kb가 기본 블록크기이므로 최대 128까지 설정 가능)
    - Multi 중간에 Single IO로 최적화하는 경우도 있음

### 1.3.7 Table Full Scan vs Index Range Scan

- 개요 : 큰 테이블에서 소량 데이터 검색시에는 반드시 인덱스를 이용해야 하지만,
  - 인덱스는 Single Block IO이기 때문에 대용량은 Table Full Scan보다 불리해짐
  - 거기에 같은걸 읽을때도 반복해 읽어 재생산성이 떨어진다.
  - 결론 : 인덱스는 중요하지만 맹신해서는 안된다. 때로는 힌트롤 이용한 Table Full Scan도 필요.

### 1.3.8 캐시 탐색 매커니즘

- 버퍼캐시 구조 : 해시 구조(해시함수->해시체인->버퍼헤더->버퍼블록)
- 직렬화 : 공유자원인 SGA를 순차적으로 접근하도록 구현한 메커니즘
  - Latch : 줄서기 지원 메커니즘. 해시체인접근중 체인구조 변경방지를 위해 체인 앞쪽을 막음
  - 버퍼 Lock : 읽을 블록을 찾고 래치를 해제하면 다른 IO가 같은 블록에 접근할 수 있게 되는데 이걸 막음

## 기타

- Direct Path IO는 메모리 버퍼 캐시를 경유하지 않는다.
