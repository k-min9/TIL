# 시큐어 코딩

- 학습 목표
  1. 웹 어플리케이션 보안의 필요성을 이해
  2. 침해사고 사례를 통해 시큐어코딩의 필요성을 이해

## 개요 및 기타

보안 : 안전하게 소프트웨어 동작을 보장하는 것
웹 애플리케이션 : 70% 이상이 웹을 통한 공격

보안약점 : SW에서 해킹 등 실제 보안사고에 악용될 수 있는 보안취약점의 근본 원인
보안취약점 : SW 실행 시점에 여러개의 보안약점 중 실제 침해 사고의 원인이 되는 보안 약점

참조할 수 있는 시큐어코딩 기준
행정안전부 소프트웨어 개발보안가이드 : 7개 분류 47개 약점

## SW 개발 보안 방법론

- SW 개발보안 : SW 개발에 보안을 고려하여 설계 구현하는 일련의 보안활동
  - 효과 : 보안점수 감소(MS사 45~91%), 비용 감소
- 시큐어 코딩 : 소스코드에 존재할 수 있는 잠재적인 보안약점을 제거하는 활동
  - 요구사항분석, 설계, 구현, 테스트, 유지보수

- 사례
  - MS SDL(보안 개발 라이프사이클) :
  교육, 계획/분석, 설계, 구현, 시험/검증, 배포/운영, 대응
  - Seven Touch Points : 개발단계에서 개발자에게 7개의 중점관리 대상을 제안하고 관리를 요구하는 방법론
  요구사항과 USECASE, 구조 설계, 테스트 계획, 코드, 테스트와 테스트결과, 현장과의 피드백

- 위협(Threat)모델 : 위협을 받는 대상인 자산(Asset)을 보호하기 위하여 가장 위험한 위협을 파악하고, 설계단계에서 보안문제에 대한 체계적인 접근과 대응 방법에 체계적인 도움을 준다.
  - 수행단계
  1. 위협모델링을 수행할 팀 구성
  2. 애플리케이션 분해 : 데이터 흐름(DFD)을 기반으로 App 분해. App의 범위를 배경도로 표시
  3. 시스템에 대한 위협 결정
  4. 결정된 위협에 대한 위험도 도출
  5. 위협 대응 기법 선정
  6. 위협 대응 기술 선정
  - MS의 위협 분류 (STRIDE)
    - Spoofing identity(신분 위장) : 거짓된 identity를 이용해 시스템 권한 획득
    - Tempering with data(데이터 변조) : 불법적 데이터 수정
    - Repudiation(부인) : 타인의 작업/트랜잭션을 부인
    - Information disclosure(정보 유출) : 유출되면 안되는 정보 유출
    - Denial of Service(서비스거부, DOS) : 시스템 또는 App이 정상적으로 수행되지 않도록
    - Elavation of privilege(권한 상승) : 비권한 사용자가 권한을 습득하여 기능 수행
  - MS의 위험도 계산 : 우선순위 결정에 쓰임
    - 예상피해 : 피해가 얼마 클것인지
    - 재현확률 : 공격 성공률이 얼마인지
    - 공격용이도 : 공격을 위해 얼마나 많은 노력이 드는지
    - 영향 받는 사용자 : 공격 성공시 얼마나 많은 사람이 영향을 받는지
    - 발견 용이성 : 취약성이 발견되기 쉬운지
  - 대응 기법 : 위협완화, 제거, 전가, 수용

## 인젝션

- SQL 인젝션
  - 개요 : 조작된 입력값으로 DB에 전달되는 쿼리(CRUD)를 변조하여, DB에 불법적인 데이터 열람, 삭제, 시스템 명령 수행 등이 발생하는 취약점
  - 원인 : 입력값에 대한 검증 작업을 수행하지 않고, 동적으로 쿼리를 생성해서 사용하는 경우 발생
  - 진단 : 직접 넣어보기. (or 'a'='a') 등의 문장을 넣는다.
  - 해결 : 자료형에 맞게 삽입되게 외부 입력값을 제어하여 명령어 구조 변경을 막는다.
  가능한 정적쿼리 사용
    1. JDBC : 삽입 값으로 조립하는 Statement API -> PreparedStatement API로 변경
    2. Hibernate(ORM) : 위와 마찬가지로 쿼리를 미리 짜두고 삽입물을 비교 (JPA로 익숙)
    3. MyBatis : ${value} 그대로 값을 전달하므로 사용 금지. #{value}로 취약점 제거
    4. 동적쿼리를 써야하는 상황 : 입력될만한 값에 대한 철저한 필터링을 수행.
    특히 쿼리문에 쓰일 만한 단어 및 함수명(IF, UNION, DROP...)을 막아야한다.

- Command 인젝션
  - 개요 : 커맨드 명령어를 넣어 해당 프로그램을 실행 삭제 하는 등 쉘 명령 제어를 할 수 있음
  - 취약 코드 : 우선 꼭 프로그램 실행 등이 필요한 기능인지 고민하고,
  꼭 필요하다면 입력값이 적절한지 꼭 확인해야 한다.

## XSS(크로스 사이트 스크립트)

- 개요 : 검증되지 않은 입력값을 응답의 일부로 사용하는 경우, [사용자 브라우저]에서 악의적인 스크립트 실행
- 종류 : Reflective, Stored(게시글 등 DB에 스크립트째 저장), DOM
- 예시
  - Reflective, Stored : JSTL Tag를 이용해 HTML 인코딩을 적용하여 해결 가능

  ```javascript
  <p>내용 : ${content}</p>
  ```

  - DOM : 정규식을 하나 만들어 a를 필터링하거나 HTML 인코딩 적용 or 텍스트노드 쓰기로 해결

  ```javascript
  var a = document.URL
  >> 이후 a를 filtering하지 않고 사용한 내용
  ```

- 해결 : 입/출력되는 헤더, 쿠키, 파라미터, 응답값에 HTML 인코딩 또는 XSS Filter를 적용
대상 : Web 컴포넌트 Filter, Interceptor 컴포넌트, Controller에 Validator or 필터링
  - 기존 시스템의 Controller에 필터링을 넣는 것은 힘들 수 있으므로 입력값 차원에서 처리하는게 좋을 수 있다.
  - 프레임워크의 Filter는 서버에 들어오는 값을 선처리/후가공 하는 역할을 하고 Chaining이 쉬우므로 적합하다.

## CSRF(크로스 사이트 요청 위조)

- 개요 : 사이트가 신뢰하는 사용자를 통해 공격자가 원하는 명령을 대신 실행하게 함
  - 웹사이트는 위조된 공격명령을 신뢰하는 사용자로부터 온것으로 판단하여 요청을 처리해버림
- 대응 : 핵심은 실제 사용자의 정상적인 요청인지 확인하는 절차를 추가하는 것
  - POST를 통한 데이터 요청 : XSS가 뚫려야 가능해지므로 1차적 차단이 가능
  - 사용자에게 할당된 CSRF Token을 사용하여 세션에 저장 후, 요청자인지 확인
  - 중요값일 경우 CAPCHA, 재인증, 다중매체 인증 등의 추가 인증을 적용
  - Spring 프레임워크 사용시 CSRF 토큰을 히든값으로 자동 첨부하게 설정 가능
    - Interceptor 컴포넌트를 이용하여 CSRF 토큰 유효성 검사를 하자

## 실습

환경 : 웹 서버(tomcat), 웹 브라우저(browser), 프록시 서버(paros)로 구축

- 인코딩 스키마 : 내용은 변하지 않지만 표현이 변함.
  표준화, 보안, 처리속도향상, 저장공간 절약등의 효과가 있지만 암호화와는 무관하다.

- 정규식을 이용한 입력값 필터링
  - 정규식 : 문자열 집합 표현식, 문자열의 검색과 치환의 용도로 사용.
    규격에 적합한 내용만 사용하게 하여 보안을 강화하게하는 등의 활용이 가능
    - . : 임의의 한 문자
    - ? : 없거나 하나 있음
    - ab* : 앞 문자(b)가 없거나 하나 이상 반복
    - ab+ : 앞 문자(b)가 하나 이상 반복
    - [] : 안에 있는 한 문자
    - [-] : (부터~까지) ex) [0-9] / [a-z] / [a-zA-Z]
    - [^] : ^ 이후의 괄호 안 문자를 제외한 한 문자
    - {} : 앞 문자 반복 횟수 ex) {2} 2회 / {2,} 2이상 / {1,2} 1또는 2
    - ^ : 문자열의 시작
    - $ : 문자열의 끝
    - () : 그룹 지정하여 괄호 내 내용을 하나의 문자로 취급
    - (|) : 그룹 지정된 내용물의 or 연산
    - (pattern) : 패턴을 찾아 일치하는 항목을 캡처
    - 이스케이프(\\) 표현 정규식 : \b. \B, \d, \D, \s. \S
    - 섞을 수 있다. ex) [0-9]+
  - 사용
    - javascript : RegExp 객체 생성
    - java : Pattern, Matcher 클래스 객체를 사용
  - 예시 password policy

  ```java
    // 하나 이상의 알파벳 포함 : (?=.[a-zA-Z]) 
    // 하나 이상의 숫자 포함 : (?=.*[0-9])
    // 하나 이상의 특수문자 포함 : (?=.*[~!@#$%^&*()_+])
    // 8글자 이상 : {8,}
    String passwordPolicy = "((?=.[a-zA-Z])(?=.*[0-9])(?=.*[~!@#$%^&*()_+]).{8,})";
    Pattern pattern = Pattern.compile(passwordPolicy);
    Matcher matcher = pattern.matcher(입력된password);
    return matcher.matches();
  ```
