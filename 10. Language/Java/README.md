# JAVA 학습

- 실습
  - 이것이 자바다
    - 타입 : 책 + 라이브코딩
  - Java로 배우는 자료구조
    - 타입 : 강의 + 라이브코딩
  - 시큐어 코딩 : 안전한 소프트웨어를 만들기 위한 보안활동
    - 타입 : 이론

- Java로 배우는 자료구조

## JAVA 체크포인트

- 개요 : Java에 대해 얘기하면 이 정도는 알아야지 하는 것 정리

### 개요

- Java : 객체 지향 프로그래밍 언어
  - 컴파일된 코드가 플랫폼 독립적이라는 것이 다른 컴파일언어와 구분 짓는 가장 큰 특징
- Java 실행 과정
  - 컴파일 과정을 통해 java 소스 코드를 실행파일(바이트 코드)로 변경
    - *.java(소스 코드)에서 .class(기계어 코드)로 변경
  - Java 실행파일을 해석할 수 있는 가상머신(JVM)이 이 파일을 해석하여 실행
    - 이 JVM이 설치 될 수 있는 어떤 플랫폼(CPU, 운영체제)에서도 실행이 가능
- Java 개발 도구
  - JVM : Java 가상 머신으로, Java 실행 파일을 해석하여 실행
  - JRE(Java Runtime Environment) : Java 언어로 만들어진 프로그램을 실행시키기 위한 환경
  - JDK(Java Development Kit) : Java 언어를 이용하여 프로그램을 개발하기 위한 환경

## 객체지향 설계 5원칙

- SOLID
  - SRP(Single Responsibility Principle): 단일 책임 원칙
    - 하나의 Class가 너무 많은 역할을 맡아서는 안된다.
    - 하나의 역할만 하도록 다수의 Class로 분할
      - Bad : 강아지 클래스의 if 수컷은 서서 싼다 else 암컷은 앉아 싼다
      - Good : 강아지 클래스를 상속받은 수컷강아지 클래스가 서서 싼다, 암컷 강아지 클래스가 앉아 싼다를 각각 구현
  - OCP(Open Closed Priciple): 개방 폐쇄 원칙, 엔티티는 확장에는 열려있지만 변경에는 닫혀있어야한다.
    - 엄청 알기 쉬운 예시 : JDBC. DB를 교체해도 Conn만 바꾸고 로직 등에 영향 없음
      - 유연성, 재사용성, 유지보수성을 위해 매우 중요한 특징
    - Bad : 자동차A가 기어수동조작이라 자동차 B로 바꿀 경우 기어자동조작메소드를 만들어야 함
    - Good : 자동차가 기어조작이라는 메소드를 만들어 자동차가 바뀌어도(확장에는 열려있고) 로직에는 변동이 없어야 함(변경에는 닫혀있음)
  - LSP(Listov Substitution Priciple): 리스코프 치환 원칙
    - 하위 클래스는 상위 클래스에 대입해도 상위 클래스일을 하는데 문제가 없어야 함
      - Bad : 계층도/조직도 (아버지-딸)
      - Good : 분류도 (포유류-개)
  - ISP(Interface Segregation Principle): 인터페이스 분리 원칙. 사용하지 않는 메서드에 의존관계를 맺어서는 안된다.
    - 큰 덩어리의 인터페이스들을 구체적이고 작은 단위들로 분리시킴으로써 클라이언트들이 꼭 필요한 메서드들만 이용
    - 각 역할에 맞게 인터페이스로 분리(어머니한테는 아들, 여자친구한테는 남자친구)
    - 상위 클래스를 풍성하게, 풍성할수록 하위 클래스에게 많은 기능을 확장시켜주고, 형변환, 코드 중복이 감소
  - DIP(Dependency Inversion Principle): 의존 역전 원칙. (결론->상위와 하위 객체 모두가 동일한 추상화에 의존해야 한다)
    - 상위 계층(정책 결정)이 하위 계층(세부 사항)에 의존하는 전통적인 의존관계를 반전(역전)시킴으로써 상위 계층이 하위 계층의 구현으로부터 독립되게 하자
      - Bad : 자동차가 스노우 타이어에 의존
      - Good : 자동차가 타이어 인터페이스에 의존

## Garbage Collection

- 개요 : JVM의 핵심 구조 중 하나. C/C++과 다르게 명시적으로 메모리를 해제하지 않아도 알아서 사용되지 않는 인스턴스를 삭제
- 방식
  - Java의 메모리 영역 중 Heap에서 동작
    - Stack은 포인터 등만 저장하는 가볍고 작은
    - Heap영역을 Young Generation과 Old Generation 영역으로 나누고 Young은 Eden, Survivor0(From), Survivor1(To)...로 나눔
      - Young 영역이 Old 영역 보다 규모가 작음. Young 영역이 다 차면 Major GC 동작.
      - 최초 생성 객체는 모두 Eden 으로 이동한다.
    - 종류
      - Minor GC : Young Genetation에서 발생하는 GC. 범위가 작아 짧은 시간 이루어지고 매우 효율적
        - 기존 객체는 각각 Eden > Survivor1 > Survivor2 > Old로 이동
      - Major GC : Old Generation에서 발생하는 GC. Minor GC의 몇십배의 시간이 걸리므로 성능에 치명적
        - GC를 실행하기 위한 Thread를 제외한 모든 Thread가 정지(Stop the world, Mark and Sweep).
        - 성능 튜닝 대상. 가능한 Major GC가 일어나지 않게 해야 함.

## Spring/Java 암호화 기술

- 개요 : 허가 된 자 이외에 읽을 수 없게 부호화 하는 기술
- 종류
  - 키 갯수
    - 대칭키(비밀키) : 키 1개
      - DES, 3-DES, AES
    - 비대칭키(공개키) : 키 2개
      - DSA, RSA
      - 공개키 암호화 : 공개키로 암호화 하고, 비밀키로 해독
      - 전자 서명 : 비밀키로 암호화 하고 공개키로 해독
  - 원본 복호화 여부
    - 단방향(MessageDigest) : 해쉬함수를 써서 출력값(Digest)를 확인하여 무결성체크하는 방식. Checksum이라고도 불림
      - 종류
        - MD5, SHA는 보안이 약하고 과거 방식이라 비추천
        - SHA2 (SHA256, SHA512)
      - 기술
        - salt : 동일한 값 다른 결과를 얻게하는 추가 요소. 실습시 secureRandom을 통해 생성해볼 수 있음.
        - stretching : 보안 강화를 위한 재해쉬. 회수를 조정하여 브루트포스 공격을 효율적으로 막을 수 있음.
    - 양방향
      - Base64 : Java 표준 API
      - URL Encoder : URL에서 사용할 문자들이 안전하게 전달되도록 브라우저가 인코딩
        - 포맷 : 기존 문자열을 HEX(16진수)값으로 병경하고 %를 붙임
- Bcrypt : Spring Security에서 기본으로 쓰는 암호화. salt 있음(적응형 함수)
  - 블로피시 암호에 기반을 둔 암호화 해시함수. 가장 강력한 해시 알고리즘 중 하나
  - SHA 경우는 GPU연산에 유리한 32비트 기반이라 공격자가 초당 억 단위의 공격이 가능
  - PKDF2(Password-Based Key Derivation Function)를 써야하는 상황(ISO=27001 보안 규정을 준수해야하는 상황)이 아니라면, 구현이 쉽고 비교적 강력해 채택
