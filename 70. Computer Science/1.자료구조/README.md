# 자료구조

- 개요 : 데이터를 어떻게 담을 것인가?
- 효과 : 효율적인 자료구조를 이해하고 사용하면 효율적인 알고리즘을 사용할 수 있다.

## Array vs LinkedList

### Array

- 개요 : 연관된 data를 메모리상에서 연속적이며 순차적으로 미리 할당된 크기만큼 저장하는 자료구조
- 특징 : 고정된 저장 공간, 순차적인 데이터 저장
- 장점 : 조회(접근과 할당)를 빠르게 할 수 있음
- 단점 : 삽입/삭제가 느림. 미리 크기를 정해야 함. 메모리 낭비가 발생할 수 있음.
  - Dynamic Array로 보완
- 기타
  - Array가 size를 넘어갈 경우 : 더 큰 Array를 선언하여 옮기고 기존 Array는 삭제(Doubling, Dynamic Array)
  - 예측하기 힘들다면 애초에 데이터를 할당 받는 방식인 LinkedList를 사용

### Linked List

- 개요 : 데이터+address로 구성된 Node라는 구조체로 이루어짐.
- 특징 : 물리적으로는 비연속이어도 논리적으로는 연속적인 데이터 구조
- 장점 : 삽입/삭제를 빠르게 할 수 있음
- 단점 : 데이터 조회가 느림
- 기타
  - 다른 자료구조를 구현할때 쓰이는 자료구조

### VS

- Array는 compile 단계에서 Stack memory에 Static Memory Allocation 할당
- L.L은 runtime Heap memory에 Dynamic Memory Allocation 할당

## 스택과 큐

### 스택

- LIFO(Last-In First-Out, 후입선출): 가장 최근에 들어온 데이터가 가장 먼저 나감

```python
push()  # 스택에 데이터 추가
pop()  # 스택에서 데이터를 삭제 (스택에서 완전히 삭제하면서 값 리턴)
is_empty()  # 스택이 공백 상태인지 검사
is_full()  # 스택이 포화상태인지 검사
create()  # 스택을 생성
peek(s)  # 요소를 스택에서 삭제하지 않고 보기만 하는 연산
```

- 스택에서 가장 최근에 입력되었던 자료를 가리키는 top 변수. 스택이 공백이면 top은 -1
- 가장 먼저 들어온 요소는 stack[0]에 저장, 가장 최근에 들어온 요소는 stack[top]에 저장
- 괄호 검사에 사용가능

- 수식 표기법: 전위(profix), 중위(infix), 후위(postfix)
  - 컴퓨터에서의 수식 계산 순서: 중위 → 후위 → 계산
  - 전위, 후위 변환을 쓰는 이유는 컴퓨터가 이해하기 쉽기 때문임(함수형 언어!)
  - 괄호의 사용이 없음
  - 스택 오버플로우
- 미로탐색 문제
  - 현재의 위치에서 가능한 방향을 스택에 저장해놓았다가 막다른 길을 만나면 스택에서 다음 탐색 위치를 꺼냄

### 큐

- FIFO(First-In First-Out, 선입선출): 먼저 들어온 데이터가 먼저 나가는 자료구조
- 선형 큐: 배열을 선형으로 사용하여 큐를 구현
  - 삽입을 계속하기 위해서는 요소의 이동이 필요함
- 원형 큐: 큐의 전단과 후단을 관리하기 위한 2개의 변수가 필요함
  - front: 첫번째 요소 하나 앞의 인덱스
  - rear: 마지막 요소의 인덱스
- deque(double-ended queue): 큐의 전단(front)과 후단(rear)에서 모두 삽입과 삭제가 가능한 큐

- 공백 상태: front == rear
- 포화 상태: front % M == (rear+1) % M
- 공백 상태와 포화 상태를 구별하기 위해 하나의 공간은 항상 비워둠

## 이진 검색 트리 (BST, Binary Search Tree)

- 정의 : 이진탐색(효율적 탐색)과 연결리스트(삽입 삭제)의 장점을 합친 트리. 최대 자식을 둘 갖는 트리
- 특징 : 일반적인 검색시간 복잡도가 O(log N), 편향(이미 잘 정렬되어있는데 추가)시 O(N)
- 보강 : 이런 단점때문에 Balanced Tree와 Red Black Tree로 자료구조를 개선 > 균형 이진 트리(최대 레벨차이가 1)
  - B Tree : DB, File System에서 사용. 둘 이상의 자식을 가질 수 있음 + 트리를 자동적으로 균형을 맞춤
  - B- Tree : 하나의 노드에 많은 정보를 담을 수 있음
  - B+ Tree : 같은 레벨의 키값들이 정렬
