# 데이터 모델링 심화

## 논리데이터 모델링

### 식별자 선정

- 규칙 : 유일성, 최소성, Not Null, 불변성
- 방법 : 대표성, 유일성을 참조, 주식별자속성이 많을 경우 대체키 활용
- 관계
  - 식별자(실선) : 의존적. FK가 식별에 반드시 필요(=부모가 반드시 필요).
  - 비식별자(점선) : 독립적. FK가 식별에 필요없고 자체 PK로 식별이 충분(FK가 아래로).

### 관계 선정

- BOM(Bill Of Material) : 하나의 엔터티 내에서 다대다관계를 맺는 형태
- 병렬관계 : 하나의 엔터티가 다른 엔터티와의 관계 역할에 따라 다른 기능을 수행
  - 부서-사원간 3종류의 점선이 그어진다던가
- 양쪽 다 선택 관계일 경우, 관계가 없는거나 다름이 없음 => 사이에 새로운 부모를 도출
- 배타적 선택 관계 : 상위 엔터티 유사시 통합
  - 주문이 개인고객, 법인고객이냐
- 관계 표현 하지 않기가 표현하기보다 중요(복잡성)
  - 관계는 FK도출을 중심으로

### 이력 모델링

- 종류
  - 변경이력 : 불특정시점 ; 주문변경, 계약변경
  - 발생이력 : 특정시점. 일자,상태코드를 활용 ; 급여계산, 요금청구, 청약관련
  - 진행이력 : 중간시점. 시작일자/종료일자가 동시에 존재가능(시점이력과 선분이력) ; 공사진행, 접수진행
- 모델링
  - 엔터티분리 : 무조건 식별자(실선)관계. 용량 감소.
    - 동일엔터티 : 회계/자금은 차변 대변 관리를 위해 한 엔터티에서 관리
    - 메타분리 : 하나의 이력엔터티로 여러 엔터티 이력관리
  - 최종여부 컬럼: SQL문이 달라짐
- 선분이력 vs 판이력
  - 선분이력 : 이력정보가 독립적. 새 이력 발생시 마스터에 영향 없이 기존 상세를 UPDATE후 INSERT
  - 판이력 : 이력정보에 반드시 마스터 이력이 필요.

### 인터페이스 모델링

- 내부 인터페이스 모델링 : 구축 시스템 내부 다른 업무 단위에 있는 엔터티와의 관계 모델링
- 외부 인터페이스 모델링 : 구축 시스템 외부 다른 시스템 엔터티 사용을 모델화
  - 오너십(주제영역)_엔터티명_IF 표기

### 코드 모델링

- 분류
  - 코드 + 코드명
  - 코드 + 코드명/추가속성 : 코드 엔터티 통합
- 특징
  - 잘 변하지 않음
  - 용량이 크지 않음
  - 많이 참조 됨
  - 사용 코드 갯수 만큼 해당 테이블의 다중 Join이 발생함
- 주의사항 : 코드나 코드값 변경시 변경해야하는 코드나 SQL(Decode)을 작성하지 말 것

### 메시지 모델링

- 메시지를 DB에 담아 출력하는 경우
  - 하나의 엔터티 / 메세지-조치를 분리하여 설계

### 일반화 모델링

- 구체화 : 개별 특성 반영 <> 일반화 : 공통특성 그룹핑
  - 엔터티일반화, 속성일반화
- 과정
  - 상품특성을 통해 상품모델 구체화
  - 구체화 된 모델을 변경과 신규에 대응 가능하게 일반화
    - 데이터 조회빈도가 높으면 기본적으로 구체화하는게 좋아보임
  - 구체화와 일반화가 혼용되는 모델 설계
- 기타 : Ultimate Metamodel by David C.Hay
  - Thing Type : 엔터티
  - Attribute : 속성
  - Relationship, Value : 관계, 실제 값(Occurrence)

### 솔루션 관점 모델링

- 배경 : 고객의 다양한 요구 변화에 솔루션 변경을 최소화하는 유연성이 중요. 변이속성과 Redundancy 제거
  - 변이속성 : 업무처리유형이나 적용사이트에 따라 사용유무가 결정되는 성격의 속성 ; 다국어, 이해관계자, 연락처...
    - 일반화 : Child 테이블 별도 구성을 통해 기존 테이블 변경을 최소화. 주식별자로 대체키 추천
  - Redundancy : 동일한 성격의 테이블이나 속성이 중복됨

## 물리 데이터 모델링

### 엔터티 통합 및 분리

- 물리적인 성능을 고려한 통합/분리를 결정
- 유사한 엔터티를 하나로 만들어 DB를 간단히 구성
  - 장 : 물리적 테이블 수 감소, ERD가 간결해져서 관리와 조회가 편리해짐
  - 단 : 업무흐름 파악이 이해가 힘들어지고 SQL 체크 조건 증가 등 개발 난이도 증가
- 방법/예시
  - 완전통합 : PK가 동일 - 등록자와 접수자는 동시에 발생함
  - 추가속성 : PK가 동일 - 구분을 넣어 통합
  - 전사관계자 통합 : 개인-조직간 새로운 역할코드 구분을 통해 역할 추가에 유연한 구조

### PK 조정

- Business Key : 비지니스적 의미가 있음 - 주민번호,사업자번호,법인번호
- System Key : 값 발생 순서대로 정해진 규칙에 맞게 부여 - 고객번호
  - 채번방법 : 채번테이블, 테이블 최대값, 시퀀스 오브젝트

### 데이터 모델 구조에 의한 성능

- 정규화를 통한 성능 향상
  - join에 의해 필요없는 내용을 스캔하는 것을 막을 수 있다.
    - Distinct로 100만건에서 추린 내용을 join할 것이 아니라 제2 정규화를 통해 걸러낸 5천건만 join
  - 속성이 중복되어 인덱스 부여가 곤란하거나 제한
    - 분류코드를 별개 테이블로 분리하고 코드에 인덱스를 건다.
- 반정규화를 통한 성능 향상
- 데이터 모델 단순화를 통한 성능 향상

### 대용량 데이터 특성을 고려한 성능

- 수평분할 : 파티셔닝
- 수직분할

### 인덱스 특성을 고려한 성능

- B-Tree : 인덱스에 쓰이는 자료구조
- 주의
  - PK 순서대로 인덱스 생성하기
  - 인덱스 후 풀 스캔하지 않게 사용
  - 인덱스가 있어도 함수 사용을 통한 컬럼 변형을 할 경우 성능 저하
  - 좁은범위로 효율적으로 조회하기
  - FK를 인덱스로 사용시, 조회나 삭제(CASCADE)에 좋은 효율이 나올 수 있음
  - 컬럼길이가 다르거나 형변환이 발생할 경우의 성능 저하
