# 개요

SQL 작성을 제외한 DB 계열 개념 요약 정리

## 인덱스

- 개요 : 검색 속도를 높이기 위해 사용하는 기술
- 방식 : 테이블의 레코드를 FULL SCAN 하는 게 아니라 색인화되어 있는 인덱스 파일을 검색
- 장단점
  - 장점
    - 테이블에서 검색과 정렬(Order by) 속도를 향상
      - Full Table Scan 방지
      - 효율적 Min, Max
    - 그룹화 작업의 속도를 향상
    - 테이블행의 고유성을 강화
  - 단점
    - 수정, 추가, 삭제 속도 감소
    - 인덱스를 위한 추가 공간 필요
    - 인덱스 생성시 시간 소요
- 생성 : 특정 컬럼을 기준으로 생성하고 기준이 된 컬럼으로 정렬된 Index 테이블이 생성
- 생성 전략
  - 조건절에 자주 등장하는 컬럼
  - 항상 = 으로 비교되는 컬럼
  - 중복되는 데이터가 최소한인 컬럼 (분포도가 좋은) 컬럼
  - ORDER BY 절에서 자주 사용되는 컬럼
  - 조인 조건으로 자주 사용되는 컬럼
- 문법
  - 생성 : CREATE INDEX [인덱스명] ON [테이블명](컬럼1, 컬럼2, 컬럼3.......)
  - 조회 : SELECT * FROM USER_INDEXES WHERE TABLE_NAME = 'CUSTOMERS'
  - 삭제 : DROP INDEX [인덱스 명]
  - 수정 : ALTER INDEX [기존 인덱스 명] TO [바뀔 인덱스 명]
  - 리빌드 : ALTER INDEX [인덱스명] REBUILD
    - 계속 생성, 삭제, 수정을 하다보면 인덱스의 효율이 감소함.
    깊이가 4쯤되면 리빌드 하는것이 효율이 좋다.
- 자료구조 : 가장 많이 사용하는 구조는 밸런스드 트리(B Tree)
  - B* Tree : 밸런스드 트리중에서도 많이 쓰임(주요 DBMS, 오라클), Root-Branch-Leaf 구조
    - Root : 일반적으로 중간 값. Min, Max Value를 가짐
    - Branch : Root를 중심으로 의해 나뉜 값들
    - Leaf : 인덱스의 키가 되는 데이터와 데이터의 물리적 주소 정보인 ROWID
- 결합 인덱스 : 두 개 이상의 컬럼을 합쳐서 인덱스를 만드는 것
  - 대상 : 단일 컬럼으로는 나쁜 분포도를 가지지만 여러 개의 컬럼을 합친다면 좋은 분포도를 가지고, Where절에서 AND 조건에 많이 사용되는 컬럼들
  - 순서결정 : B Tree의 구조상 순서가 매우 중요. 선언 순서대로 검색함
    - 주의 : 순서를 맞추더라도 Like 같은 넓은 범위나 중간에 빠진 where and 검색을 할 경우 Full Record Scan하는것이나 다름 없어진다.

## REDIS

- 개요 : String, Hash, List, Set, Sorted Set 등 다양한 데이터 형식을 제공하는 키-값(Key-Value) 데이터 저장소
- 특징
  - 빠름 : 인메모리DB > 디스크, 채팅 구현시 RDB 대비 응답시간 36% 감소
    - 인메모리 : 컴퓨터의 메인 메모리 RAM에 데이터를 올려서 사용하는 방법
  - 원자성 : 싱글 스레드라서 원자성을 보장
  - 직관적 : key-value
  - DB 내에 TTL을 설정할 수 있음(개인 감상)
- 단점
  - 휘발성 : 메모리에 올라가기 때문에 전원이 내려가면 날라감
    - 영속성(Persistence)을 위해 Disk에 백업
      - 스냅샷 : 시간마다 파일째 저장
      - AOF : 연산 자체를 저장. 꼼꼼하게 하는 만큼 백업이 느리지만 촘촘한 복원이 가능
    - 기타 대비 : 외부 서버 내지 다중 서버를 사용, 날라가도 괜찮은 내용을 저장
  - 싱글스레드 : 원자성을 보장하지만 반대로 1번에 1개의 명령어만 실행 가능해 사용에 주의 필요
    - 비쌈! (개인 감상. 무료 용량 30mb라니...)
    - 모든 key를 보여주거나 모든 데이터를 flush하거나 하면 매우 느려짐
- 활용
  - 캐시 데이터 서버(Global Cahce Server) : 여러 서버에서 접근하여 사용하는 캐시 서버
    - cache : 자주 사용하는 데이터나 값을 미리 복사해 놓는 임시 장소  
    한 번 읽어온 데이터를 저장해 부하를 줄이고, 재요청시 빠르게 결과를 반환할 수 있게 됨
  - 메시지, 채팅
  - 단순 프로토콜 Pub/Sub
  - 최근 검색목록, 유저 인증 토큰, 랭킹 보드

## DBMS에 쓰이는 자료구조

- 이진 탐색 트리의 단점 : (기존에 정렬 되어있으면) 최악의 경우 높이가 n이 됨
- 레드 블랙 트리 : 이진 탐색 트리의 일종이지만 이진탐색트리의 단점을 없앰
  - O(log N)의 시간복잡도로 삽입, 삭제, 검색이 보장(worst-case guarantees)
  - 특성
    - 각 노드의 색은 red or black
    - root와 leaf는 black
    - red는 연속하여 등장할 수 없다  
    (= red의 자식노드는 무조건 black)
    (= 노드의 절반 이상이 black 노드)
    - root부터 leaf까지의 black 노드 개수는 동일하다!
  - 효과 : 따라서 최악의 경로 길이가 최단 경로 길이의 2배 이상이 될 수가 없다.
  - 동작 : 삽입시 Red 노드로 삽입하고, 크면 오른쪽 작으면 왼쪽 등 기본적인 흐름은 BST와 비슷하지만 특성을 위한 마무리 작업(restructuring(rotation + @), recoloring)이 있다.
  - vs B-tree : B-tree는 하나의 노드에 여러 데이터를 가질 수 있음
    - B-Tree : 메모리의 배열(인덱스) 형식 접근 > 같은 O(log N)이어도 더 빠름
      - DB 인덱스 등에 사용
    - RedBlack-Tree : 참조 포인터 접근 > 포인터 접근 수가 더 많음
      - 저장, 삭제 시 B-Tree보다 빠름. 숫자등의 비교 가능한 자료 정리

## 기타

- WITH UR FOR READ ONLY
  - UR : 격리 레벨 Uncommitted Read
  - SELECT에서만 사용
  - 실시간 변경중인 데이터를 가져올 수 있음  
  (= 락이 걸려있는 테이블도 트랜잭션 종료를 기다리지 않고 볼 수 있음)
  - 신뢰성이 보장되지 않음
- WHERE 1=1
  - 성능상 개선은 없음. 편의성 문제!
  - 타 where문의 주석 처리하기가 편하다
  - 동적 쿼리 작성시 첫 스타트를 간결하게 작성할 수 있다.
